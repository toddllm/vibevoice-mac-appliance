#!/usr/bin/env python3
"""
vvctl: Production Mac VibeVoice CLI (Final)

Complete CLI with warmup, cache verification, and stdin support.
"""

import argparse
import os
import sys
import time
import json
import hashlib
import numpy as np
import soundfile as sf
import torch
from pathlib import Path

# Hardened environment
ENV_VARS = {
    "HF_HUB_OFFLINE": "1",
    "TRANSFORMERS_OFFLINE": "1",
    "TRANSFORMERS_NO_FLASH_ATTENTION": "1",
    "PYTORCH_ENABLE_MPS_FALLBACK": "1",
    "PYTORCH_MPS_HIGH_WATERMARK_RATIO": "0.0",
    "OMP_NUM_THREADS": "8",
    "VECLIB_MAXIMUM_THREADS": "8"
}

for key, value in ENV_VARS.items():
    os.environ.setdefault(key, value)

from mac_config import MODEL_CONFIGS
from hardened_synthesis import synthesize_with_validation

def cmd_warmup(args):
    """Warmup models and caches for stable performance."""
    print("üî• Warming up Mac VibeVoice...")
    
    start_time = time.time()
    
    result = synthesize_with_validation(
        model_id="1.5B",
        text="Speaker 0: Warmup test.",
        voice_path=args.voice,
        seconds=1.0,
        output_path="temp/warmup.wav",
        request_id="warmup"
    )
    
    warmup_time = time.time() - start_time
    
    # Clean up warmup file
    try:
        os.remove("temp/warmup.wav")
    except:
        pass
    
    if result["success"]:
        print(f"‚úÖ Warmup complete: {warmup_time:.2f}s")
        print(f"üéØ Models cached, ready for fast synthesis")
        
        # Store warmup time for future reference
        warmup_data = {
            "last_warmup": time.time(),
            "warmup_time": warmup_time,
            "model": "1.5B"
        }
        
        os.makedirs("temp", exist_ok=True)
        with open("temp/last_warmup.json", "w") as f:
            json.dump(warmup_data, f)
            
        return 0
    else:
        print(f"‚ùå Warmup failed: {result['error']}")
        return 1

def cmd_verify_cache(args):
    """Verify model cache integrity with SHA256 checks."""
    print("üîç Verifying model cache integrity...")
    
    from atomic_audio import verify_cache_integrity, create_integrity_manifest
    
    models_to_check = ["1.5B"]
    if args.all and MODEL_CONFIGS["7B"]["snapshot_path"]:
        models_to_check.append("7B")
    
    all_valid = True
    manifest_data = {"models": {}, "verified_at": time.time()}
    
    for model_id in models_to_check:
        print(f"\nVerifying {model_id}...")
        
        verification = verify_cache_integrity(model_id)
        manifest_data["models"][model_id] = verification
        
        if verification["valid"]:
            print(f"‚úÖ {model_id}: Cache integrity verified")
            
            # Show file summary
            files = verification["files"]
            total_size = sum(f["size"] for f in files.values())
            print(f"   Files: {len(files)}, Total size: {total_size//1024//1024}MB")
            
            if args.verbose:
                for filename, info in files.items():
                    size_mb = info["size"] // 1024 // 1024
                    print(f"   {filename}: {size_mb}MB, hash: {info['hash']}")
        else:
            print(f"‚ùå {model_id}: Cache integrity failed")
            for error in verification["errors"]:
                print(f"   Error: {error}")
            all_valid = False
    
    # Save integrity manifest
    if args.save_manifest:
        manifest_path = args.save_manifest
        if create_integrity_manifest("1.5B", manifest_path):
            print(f"\n‚úÖ Integrity manifest saved: {manifest_path}")
        else:
            print(f"\n‚ùå Failed to save manifest")
            all_valid = False
    
    if all_valid:
        print(f"\nüéØ All model caches verified successfully")
        return 0
    else:
        print(f"\n‚ùå Cache verification failed")
        print(f"üí° Run: ./scripts/sync_hf_cache_from_toddllm.sh")
        return 1

def cmd_synth_stdin(args):
    """Synthesize from stdin for long scripts."""
    print("üìñ Reading text from stdin...")
    
    # Read all text from stdin
    text = sys.stdin.read().strip()
    
    if not text:
        print("‚ùå No text provided on stdin")
        return 1
    
    print(f"‚úÖ Read {len(text)} characters")
    print(f"Text preview: {text[:100]}...")
    
    # Use regular synthesis
    args.text = text
    return cmd_synth(args)

def cmd_synth(args):
    """Enhanced synthesis with comprehensive validation."""
    print(f"üéôÔ∏è  Mac VibeVoice Synthesis")
    print(f"Model: {args.model}")
    print(f"Duration: {args.seconds}s")
    
    if hasattr(args, 'text'):
        print(f"Text: {args.text[:60]}...")
    
    # Generate paths
    timestamp = int(time.time())
    if hasattr(args, 'out') and args.out:
        output_path = args.out
    else:
        os.makedirs("out", exist_ok=True)
        output_path = f"out/{args.model.lower()}_{timestamp}.wav"
    
    request_id = f"cli-{timestamp}"
    
    # Pre-flight checks
    if args.model not in MODEL_CONFIGS:
        print(f"‚ùå Unknown model: {args.model}")
        return 1
    
    config = MODEL_CONFIGS[args.model]
    if not os.path.exists(config["snapshot_path"]):
        print(f"‚ùå Model snapshot not found: {config['snapshot_path']}")
        print(f"üí° Run: ./scripts/sync_hf_cache_from_toddllm.sh")
        return 1
    
    # Synthesize with full validation
    result = synthesize_with_validation(
        model_id=args.model,
        text=args.text,
        voice_path=args.voice,
        seconds=args.seconds,
        output_path=output_path,
        request_id=request_id
    )
    
    if result["success"]:
        metrics = result["metrics"]
        print(f"\n‚úÖ SUCCESS! ({request_id})")
        print(f"Saved: {output_path}")
        print(f"Duration: {metrics['duration']:.2f}s")
        print(f"Wall time: {metrics['wall_time']:.2f}s")
        print(f"RTF: {metrics['rtf']:.2f}x")
        
        if "chunk_count" in metrics:
            print(f"Chunks: {metrics['chunk_count']} ({metrics.get('put_count', 0)} put calls)")
            if metrics.get("first_chunk_ms"):
                print(f"First chunk: {metrics['first_chunk_ms']:.0f}ms")
        
        # Output metrics as JSON if requested
        if getattr(args, 'metrics', False):
            print(f"\nüìä Metrics JSON:")
            print(json.dumps(metrics, indent=2))
        
        return 0
    else:
        print(f"\n‚ùå FAILED: {result['error']}")
        return 1

def main():
    """Enhanced CLI with all production features."""
    parser = argparse.ArgumentParser(description="Mac VibeVoice Production CLI")
    subparsers = parser.add_subparsers(dest="command", help="Commands")
    
    # Synth command
    synth_parser = subparsers.add_parser("synth", help="Synthesize speech")
    synth_parser.add_argument("--model", choices=["1.5B", "7B"], required=True)
    synth_parser.add_argument("--voice", required=True, help="Voice WAV file")
    synth_parser.add_argument("--text", help="Text to synthesize (or use --stdin)")
    synth_parser.add_argument("--stdin", action="store_true", help="Read text from stdin")
    synth_parser.add_argument("--from-file", "-f", help="Read text from file")
    synth_parser.add_argument("--seconds", type=float, default=6.0, help="Target duration")
    synth_parser.add_argument("--out", help="Output file path")
    synth_parser.add_argument("--metrics", action="store_true", help="Output metrics JSON")
    synth_parser.add_argument("--verbose", action="store_true", help="Verbose output")
    synth_parser.add_argument("--no-save", action="store_true", help="Don't save audio file")
    
    # Warmup command
    warmup_parser = subparsers.add_parser("warmup", help="Warmup models and caches")
    warmup_parser.add_argument("--voice", required=True, help="Voice file for warmup")
    
    # Verify cache command
    verify_parser = subparsers.add_parser("verify-cache", help="Verify model cache integrity")
    verify_parser.add_argument("--all", action="store_true", help="Check all models")
    verify_parser.add_argument("--verbose", action="store_true", help="Verbose output")
    verify_parser.add_argument("--save-manifest", help="Save integrity manifest to file")
    
    # Diagnostic command
    diag_parser = subparsers.add_parser("diag", help="System diagnostic for issue reporting")
    diag_parser.add_argument("--json", action="store_true", help="Output JSON format")
    
    # Health command with JSON option
    health_parser = subparsers.add_parser("health", help="System health check")
    health_parser.add_argument("--json", action="store_true", help="Output JSON format")
    
    args = parser.parse_args()
    
    if args.command == "synth":
        # Handle different text input methods
        if args.stdin:
            return cmd_synth_stdin(args)
        elif hasattr(args, 'from_file') and args.from_file:
            with open(args.from_file, 'r') as f:
                args.text = f.read().strip()
            return cmd_synth(args)
        elif not args.text:
            print("‚ùå Text required: use --text, --stdin, or --from-file")
            return 1
        else:
            return cmd_synth(args)
    elif args.command == "warmup":
        return cmd_warmup(args)
    elif args.command == "verify-cache":
        return cmd_verify_cache(args)
    elif args.command == "diag":
        from vvctl_diag import cmd_diag
        return cmd_diag(args)
    elif args.command == "health":
        return cmd_health(args)
    else:
        parser.print_help()
        return 1

if __name__ == "__main__":
    exit(main())